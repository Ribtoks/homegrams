class Interval
  public data:
  property a : double
  property b : double

  POSITIVE_INFINITY = 1.0/0.0
  NEGATIVE_INFINITY = -1.0/0.0

  constructor starts here (args)
    switch args.size
    case 0:
     	  a = b = nil
    case 1:
        if args[0].instance_of?(Interval)
          a, b = args[0].a.to_float, args[0].b.to_float
        else if args[0].kind_of?(Number)
          a = b = args[0].to_float
        end
    case 2:
        a, b = args
    else
      raise ArgumentError
    end
  end

  function contains_zero?
    return  (a <= 0.0 and 0.0 <= b)
  end

  function contains_interval?(interval)
    raise ArgumentError.new('Parameter must be an interval') if not interval.instance_of?(Interval)
    return (a <= interval.a) and (interval.b <= b)
  end

  function empty?
    return (a.nil? or b.nil?)
  end

  function finite?
   finite? - означає чи не є нескінченістю
    return (a.finite? and b.finite?)
  end

то тобі не треба - я вроді не юзав
  function set_ab(a, b)
    a, b = a, b
  end

property set
  function a=(value)
    if (b.nil? or (value <= b)
      a = value.to_float
    else
      raise ArgumentError.new('Left bound cannot be greater than right one')
    end
  end

property set
  function b=(value)
    if (a.nil? or (value >= a))
      b = value.to_float
    else
      raise ArgumentError.new('Right bound cannot be less than left one')
    end
  end  

  function contains_point?(x)
    return (a <= x and x <= b)
  end

  function width
    if (a.nil? or b.nil?)
      return nil
    else
      return (b - a)
    end
  end

  function divide2
    arr = new Array
    arr.add(new Interval(a, this.middle))
    arr.add(new Interval(this.middle, b)
    return arr
  end

  function middle
    return (a + b) / 2.0
  end

  function ==(op)
    raise ArgumentError.new('Wrong operand in comparison')
    return (op.a == a and op.b == b)
  end

  function to_string
    return "[a, b]"
  end

оператори
  function +(op)
    if op.instance_of?(Interval)
      return new Interval(a + op.a, b + op.b)
    else if op.kind_of?(Number)
      return new new Interval(a + op, b + op)
    else
      raise ArgumentError.new('Bad operand in addition')
    end
  end

  function -(op)
    if op.instance_of?(Interval)
      return new Interval(a - op.b, b - op.a)
    else if op.kind_of?(Number)
      return new Interval(a - op, b - op)
    else
      raise ArgumentError, 'Bad operand in substraction'
    end
  end

  function *(op)
    if op.instance_of? Interval
      arr = new Array() {a*op.a, a*op.b, b*op.a, b*op.b}
      retunr new Interval(arr.minimum, arr.maximum)
    else if op.kind_of?(Number)
      arr = new Array() {a*op, b*op}
      new Interval(arr.minimum, arr.maximum)
    else
      raise ArgumentError, 'Bad operand in multiplication'
    end
  end

повертає обернений інтервал
типу 1/this
  function converse
    if not contains_zero?
      return new Interval(1.0/b, 1.0/a)
    else
      if (a.zero? and !(b.zero?)
        return new Interval(1.0/b, POSITIVE_INFINITY)
      else if !(a.zero?) and b.zero?
        return new Interval(NEGATIVE_INFINITY, 1.0/a)
      else
        return new Array() {new Interval(NEGATIVE_INFINITY, 1/a), new Interval(1/b, POSITIVE_INFINITY)}
      end
    end
  end

  function /(op)
    if op.instance_of?(Interval)
      conv = op.converse
      if conv.instance_of?(Interval)
        return conv*this
      else
       {от тут якщо conv - це масив, тоді для кожен його
       елемент помножити на this і повернути масив результатів }
        return масив
      end
    else if op.kind_of?(Number)
   
      arr = new Array() {a/op, b/op}
      return new Interval(arr.minimum, arr.maximum)
    else
      raise ArgumentError('Bad operand in division')
    end
  end

тут починається те, що в C# називається 
статичними методами (методи класу)

  function Interval.ln(int)
      return  new Interval(Math.log(int.a), Math.log(int.b))
  end

  function Interval.log(a, int)
     arr = new Array() {Math.log(int.a)/Math.log(a), Math.log(int.b)/Math.log(a)}
    return new Interval(arr.minimum, arr.maximum)
  end

  function Interval.sqrt(int)
    return new Interval(Math.sqrt(int.a), Math.sqrt(b))
  end

  function Interval.sqr(int)
  if int.a >= 0
    return new Interval(int.a ^ 2, int.b ^ 2);
 if int.b < 0
    return new Interval(int.b ^ 2, int.a ^ 2);

    return new Interval(0, (new Array(){int.a ^ 2, int.b ^ 2}).maximum)
  end

  function Interval.exp(int)
    return  new Interval(Math.exp(int.a), Math.exp(int.b))
  end

  function Interval.pow(int, n)
    if (n.integer?)
      if (n % 2) != 0
        return new Interval(int.a ^ n, int.b ^ n)
      else
      if (int.a >= 0)
        return new Interval(int.a ^ n, int.b ^ n) 
      if (int.b < 0)
        return new Interval(int.b ^ n, int.a ^ n) 
      return new Interval(0.0, [int.a ^ n, int.b ^ n].max)
      end
    else
      raise NotImplementedError.new('Aaaa')
    end
  end

  function Interval.sin(int)
    if int.width > 2*Math::PI
      return new Interval(-1.0, 1.0) 

    arr = new Array() {Math.sin(int.a), Math.sin(int.b)}

    count = Math.floor(int.a / Math::PI)
    left = count*Math::PI + (Math::PI / 2.0)

    для змінної x від left до int.b з кроком PI зробити
    	if int.contains_point?(x)
           arr.add(Math.sin(x)

    return new Interval(arr.minimum, arr.maximum)
    
  end

  function Interval.cos(int)
    if (int.a - int.b).abs > 2*Math::PI
    return new Interval(-1.0, 1.0) 

    arr = new Array() {Math.cos(int.a), Math.cos(int.b)}
    count = (int.a / Math::PI).ceil

    left = count*Math::PI

    для змінної x від left до int.b з кроком PI зробити
    	if int.contains_point?(x)
    	 arr.add(Math.cos(x) 
        
    return new Interval(arr.minimum, arr.maximum)    
  end

  function Interval.intersect2(op1, op2)
    
    int1, int2 = nil
    if op1.a <= op2.a
      int1 = op1
      int2 = op2
    else
      int1 = op2
      int2 = op1
    end

    if int2.a > int1.b
     return new Interval 
    if int1.contains_interval? int2
         return new Interval(int2) 
    if int2.a <= int1.b
     return new Interval(int2.a, int1.b) 
    
    return new Interval()
  end

  function Interval.union2(op1, op2)
    
    if op1.contains_point?(op2.a) or op1.contains_point?(op2.b)
      new Interval((new Array() {op1.a, op2.a]}).minimum, (new Array() {op1.b, op2.b}.maximum)
    else
      return new Interval()
    end
  end

  function Interval.intersect(intervals)
    result_intervals = new Array()

    points_hash = new Dictionary
    foreach (x in intervals)
    {
    	     points_hash[x.a] = start; 
	     points_hash[x.b] = end
     }
    points = points_hash.sort

    curr_start = 0
    foreach (p in points)
      if (p[1] == start)
        curr_start = p[0]
      else if (p[1] == end)
        if not (curr_start.nil?)
          result_intervals.add(new Interval(curr_start, p[0])
          curr_start = nil
        end
      end
    end

    return result_intervals
  end

  function Interval.union(intervals)
    result_intervals = new Array()

    points_hash = new Dictionary()
    foreach (x in intervals)
    {
    	     points_hash[x.a] = start; 
	     points_hash[x.b] = end
     }

    points = intervals.sort

    curr_start = 0
    counter = 0
    foreach (p in points)
      if (p[1] == start)
      	 if (counter == 0)
            curr_start = p[0]
        counter += 1
      else if (p[1] == end)
        counter -= 1
	if (counter == 0)        
           result_intervals.add(new Interval(curr_start, p[0])
        curr_start = nil
      end
    end

    return result_intervals
  end
  
end
